#!/usr/bin/env python

from argparse import ArgumentParser
from sys import exit, version_info
from mimetypes import guess_type
from os.path import isfile
from tempfile import NamedTemporaryFile
from subprocess import call
from base64 import b64encode
from string import Template
from subprocess import Popen, PIPE
from json import loads

def get_mimetype(filename):
  return(guess_type(filename)[0])

def get_extension(filename):
  return(get_mimetype(filename).split("/")[1])

def to_base64(filename):
  with open(filename, "rb") as f:
    return(b64encode(f.read()).decode("utf-8"))

html = Template(
"""<!DOCTYPE html>
<html>
  <meta charset=\"utf-8\">
  <title>$title (${width}x${height}px)</title>
  <style type=\"text/css\">
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
    }
    html {
      display: table;
    }
    body {
      display: table-cell;
      vertical-align: middle;
      text-align: center;
      background-color: ${color};
    }
    video, source {
      display: block;
      margin: 0 auto;
    }
  </style>
  <video width=\"${width}\" height=\"${height}\" autoplay=\"autoplay\" loop=\"\">
    <source type=\"${mimetype}\" src=\"data:${mimetype};base64,${data}\">
  </video>
</html>"""
)

def main():

  parser = ArgumentParser("gif2gfy")
  parser.add_argument("-i", "--infile", help="Input file")
  parser.add_argument("-c", "--color", default="black", help="Choose background color of gfy; default is black")
  parser.add_argument("-o", "--outfile", help="Set filename of output; default is o.{mp4,webm}.html")
  parser.add_argument("-p", "--path", help="Specify a custom directory to look for FFmpeg and FFprobe")
  parser.add_argument("-q", "--quality", default="3.5", help="Set bitrate in MBs for gif-to-webm conversion; default is 3.5")
  parser.add_argument("-t", "--title", help="Set title in HTML page; default is whatever -o is set to")

  args = vars(parser.parse_args())

  if not args["infile"]:
    print("No file specified. Aborting.")
    exit()

  if not isfile(args["infile"]):
    print("{0} isn't a file. Aborting.".format(args["infile"]))
    exit()

  # Python3.3 shutil.which(), which is a more reliable method for checking
  # program availability than distutils.spawn.find_executable()
  if version_info >= (3, 3):
    from shutil import which
  else:
    from distutils.spawn import find_executable as which

  ffmpeg, ffprobe = which("ffmpeg"), which("ffprobe")

  if not ffmpeg or ffprobe:
    print("FFmpeg needs to be installed to continue. Aborting.")
    exit()
  
  in_mimetype = get_mimetype(args["infile"])
  in_extension = get_extension(args["infile"])

  with NamedTemporaryFile() as temp:
    if in_extension in ("webm", "mp4"):
      custom = "-f {0} -vcodec copy -an".format(in_extension)
      out_mimetype, out_extension = in_mimetype, in_extension

    elif in_mimetype == "image/gif":
      bitrate = "{0}M".format(args["quality"], args["quality"], args["quality"])
      custom = "-f webm -minrate {0} -maxrate {1} -b:v {2}".format(bitrate, bitrate, bitrate)
      out_mimetype, out_extension = "video/webm", "webm"

    else:
      print("Not a supported filetype. Aborting.")
      exit()

    ffmpeg_parameters = "-i {0} -y -loglevel quiet {1}".format(args["infile"], custom)
 
    call("{0} {1} {2}".format(ffmpeg, ffmpeg_parameters, temp.name), shell=True)

    ffprobe_parameters = "-loglevel quiet -show_entries stream=width,height -print_format json -i"
    out = Popen("{0} {1} {2}".format(ffprobe, ffprobe_parameters, temp.name), stdout=PIPE, shell=True)
    output, err = out.communicate()

    json = loads(output.decode("utf-8"))
    dimensions = json["streams"][0]

    if not args["outfile"]:
      outfile = "o.{0}.html".format(out_extension)

    if not args["title"]:
      title = outfile

    data = {
      "title": title,
      "mimetype": out_mimetype,
      "width": dimensions["width"],
      "height": dimensions["height"],
      "color": args["color"],
      "data": to_base64(temp.name)
    }
  
  with open(outfile, "w") as f:
    f.write(html.substitute(data))

if __name__ == "__main__":
  main()

