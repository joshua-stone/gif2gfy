#!/usr/bin/env python

from argparse import ArgumentParser
from sys import exit, version_info
from mimetypes import guess_type
from os.path import isfile, abspath
from base64 import b64encode
from string import Template
from subprocess import Popen, PIPE
from json import loads
from os import sep, access, X_OK

def get_mimetype(filename):
  return(guess_type(filename)[0])

def get_extension(filename):
  return(get_mimetype(filename).split("/")[1])

def is_executable(filename):
  return(isfile(filename) and access(filename, X_OK))

html = Template(
"""<!DOCTYPE html>
<html>
  <meta charset=\"utf-8\">
  <title>$title (${width}x${height}px)</title>
  <style type=\"text/css\">
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
    }
    html {
      display: table;
    }
    body {
      display: table-cell;
      vertical-align: middle;
      text-align: center;
      background-color: ${color};
    }
    video, source {
      display: block;
      margin: 0 auto;
    }
  </style>
  <video width=\"${width}\" height=\"${height}\" autoplay=\"autoplay\" loop=\"\">
    <source type=\"${mimetype}\" src=\"data:${mimetype};base64,${data}\">
  </video>
</html>"""
)

def main():

  parser = ArgumentParser(prog="gif2gfy", description="An FFmpeg frontend for converting gifs into standalone gfy files.")
  parser.add_argument("-i", "--infile", required=True, help="Input file")
  parser.add_argument("-c", "--color", default="black", help="Choose background color of gfy; default is black")
  parser.add_argument("-o", "--outfile", help="Set filename of output; default is o.{mp4,webm}.html")
  parser.add_argument("-p", "--path", help="Specify a custom directory to look for FFmpeg and FFprobe")
  parser.add_argument("-q", "--quality", default="3.5", help="Set bitrate in MBs for gif-to-webm conversion; default is 3.5")
  parser.add_argument("-t", "--title", help="Set title in HTML page; default is whatever -o is set to")
  parser.add_argument("-v", "--video", action="store_true", help="Output pure video instead of HTML")

  args = vars(parser.parse_args())

  if not isfile(args["infile"]):
    print("{0} isn't a file. Aborting.".format(args["infile"]))
    exit()

  """
  Often FFmpeg isn't available due to lack of packaging on Windows and
  Debian-based distros, so being able to define a custom path is a
  sensible fallback
  """
  if args["path"]:
    full_path = abspath(args["path"]) + sep 
    custom_ffmpeg, custom_ffprobe = full_path + "ffmpeg", full_path + "ffprobe"

    if is_executable(custom_ffmpeg) and is_executable(custom_ffprobe):
      ffmpeg = custom_ffmpeg
      ffprobe = custom_ffprobe
    else:
      print("{0} doesn't have FFmpeg or FFprobe. Aborting.".format(full_path))
      exit()

  else: 
  # Python3.3 shutil.which(), which is a more reliable method for checking
  # program availability than distutils.spawn.find_executable()
    if version_info >= (3, 3):
      from shutil import which
    else:
      from distutils.spawn import find_executable as which

    ffmpeg, ffprobe = which("ffmpeg"), which("ffprobe")

  if not ffmpeg or not ffprobe:
    print("FFmpeg needs to be installed to continue. Aborting.")
    exit()
  
  in_mimetype = get_mimetype(args["infile"])
  in_extension = get_extension(args["infile"])

  if in_extension in ("webm", "mp4"):
    custom = ["-f", "webm", "-vcodec", "copy", "-an"]

    out_mimetype, out_extension = in_mimetype, in_extension

  elif in_mimetype == "image/gif":
    bitrate = "{0}M".format(args["quality"])
    custom = ["-f", "webm", "-minrate", bitrate, "-maxrate", bitrate, "-b:v", bitrate]
    out_mimetype, out_extension = "video/webm", "webm"

  else:
    print("Not a supported filetype. Aborting.")
    exit()
 
  call_ffmpeg = [ffmpeg, "-i", args["infile"], "-loglevel", "quiet"] + custom + ["pipe:1"]
  ffmpeg_output = Popen(call_ffmpeg, stdout=PIPE)
  video_data, err = ffmpeg_output.communicate()

  if not args["video"]:
    call_ffprobe = [ffprobe, "-i", "-", "-loglevel", "quiet", "-show_entries", "stream=width,height", "-print_format", "json"]
    ffprobe_output = Popen(call_ffprobe, stdin=PIPE, stdout=PIPE)
    raw_json = ffprobe_output.communicate(input=video_data)[0]
    json = loads(raw_json.decode("utf-8"))

    dimensions = json["streams"][0]
  
    if args["outfile"]:
      outfile = args["outfile"]
    else:
      outfile = "o.{0}.html".format(out_extension)

    if args["title"]:
      title = args["title"]
    else:
      title = outfile

    data = html.substitute({
      "title": title,
      "mimetype": out_mimetype,
      "width": dimensions["width"],
      "height": dimensions["height"],
      "color": args["color"],
      "data": b64encode(video_data)
    })

  else:
    if args["outfile"]:
      outfile = args["outfile"]
    else:
      outfile = "o.{0}".format(out_extension)

    data = video_data

  full_outfile_path = abspath(outfile)

  with open(full_outfile_path, "wb") as f:
    f.write(data)
 
  print(full_outfile_path)

if __name__ == "__main__":
  main()

